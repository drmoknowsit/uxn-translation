|0100
( unit tests ) 
test-set_bit 


@set-bitmap-A
    #01 ;bitmap #0001 ADD2 STA 
    #80 ;bitmap #0003 ADD2 STA 
    #02 ;bitmap #0004 ADD2 STA 
    #60 ;bitmap #0008 ADD2 STA 
    #04 ;bitmap #000c ADD2 STA 
    #20 ;bitmap #000d ADD2 STA 
JMP2r

@set-bitmap-B
    #03 ;bitmap #0001 ADD2 STA ( positions: 16=0,15=1 )
    #c0 ;bitmap #0003 ADD2 STA ( positions: 24=1,25=1 )
    #07 ;bitmap #0004 ADD2 STA ( positions: 37=1,38=1 )
    #60 ;bitmap #0008 ADD2 STA ( positions: 65=0,66=1 )
    #0e ;bitmap #000c ADD2 STA ( positions: 100=1,101=1 )
    #30 ;bitmap #000d ADD2 STA ( position: 106=1,107=1 )
JMP2r

@set_bit ( idx -- )
!todo
find_bit
mask_set
;find_byte/byte LDA ORA
;bitmap ADD2 STA
JMP2r



@mask_set ( bit_idx* -: mask )
.bit_idx STZ2
#01 .bit_idx LDZ2 NIP #40 SFT SFT
JMP2r


@find_byte
.&idx LDA2 #03 SFT ( divides idx by 8 to give byte position )
( stack: idx//8 )
;bitmap ADD2 LDA ( gets bitmap address, adds byte address to it, loads address, loads byte )
( stack: address byte )
SWP2 POP2 ;&byte STA2 ( stack:  )
JMP2r
&byte $2

@find_bit
find_byte
.&idx LDA2 DUP2 #33SFT2 SUB2 ( loads idx and duplicates. Shifts right and left to get top hex digit isolated. Takes this away from the idx lower on the stack to get remainder - bit position )
( stack: bit position LtoR )
#07 SWP2 SUB2 NIP ( this line flips round bit placement as uxntal starts with position 0 on the right. The result is the uxntal bit position. NIP to just get lower nibble. The result is stored and kept on the stack)
( stack: bit position RtoL )
;find_byte/byte LDA SWP2 POP2 ( loads byte address loads byte swaps position to pop address)
SWP2 SFT NIP ( swaps order so bit position at top of stack, shifts to get bit at position 0, nips to isolate just that bit )
( stack: just bit we want )
JMP2r


@test-set_bit ( -- )
    { 0016 "Test 20 "for 20 "set_bit(idx) 0a } STH2r print-str
    #000f set_bit #000e set_bit
    #0018 set_bit #0019 set_bit
    #0026 set_bit #0027 set_bit
    #0041 set_bit #0042 set_bit
    #0065 set_bit #0066 set_bit
    #006a set_bit #006b set_bit
JMP2r


( Constants )
@PAGE_SZ ( -: a* ) #0010 JMP2r ( We allocate 16 bytes per page )
@N_PAGES ( -: a* ) #0100 JMP2r ( We have a total of 256 pages, so we can allocate at most 4kB )
@DMEM_START ( -: a* ) #f000 JMP2r ( Start at 60*1024 )
@MAX_N_ALLOCS ( -: a* ) #0020 JMP2r ( We can allocate at most 32 regions )
@MAX_ALLOC_SZ ( -: a* )  
PAGE_SZ N_PAGES MUL2
JMP2r
( Counter to track number of allocations )
( The allocation map is in allocation-map.tal )
@n_allocs 0000

 ( N_PAGES bits, packed in bytes mean N_PAGES/8 entries, so with the above, the bitmap will take 64 bytes )
 ( 0 means free )
@bitmap $40

( The allocation happens below this )
|f000
@vmem
